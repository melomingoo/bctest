package handler

import (
	"bc_melomingoo/message"
	"bc_melomingoo/processor"
	"encoding/json"
	"fmt"
	"github.com/gorilla/schema"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"strings"
)

type CoinHandler BaseHandler

func (h *CoinHandler) CoinHandlerList(w http.ResponseWriter, r *http.Request) {

	_ = r.ParseForm()
	requestData := &message.CoinCurrentListRequest{}
	decoder := schema.NewDecoder()
	err := decoder.Decode(requestData, r.Form)
	if err != nil {
		//replyError(w, requestLogger, http.StatusBadRequest, err)
		//return
	}

	client := &http.Client{}
	request, err := http.NewRequest(http.MethodGet, fmt.Sprintf("%s/v2/cryptocurrency/quotes/latest", h.Config.CoinMarket.Host), nil)
	if err != nil {
		//return err
	}
	q := url.Values{}
	//q.Add("start", "1")
	//q.Add("limit", "5000")
	q.Add("symbol", requestData.Target)
	q.Add("convert", requestData.Currency)

	request.Header.Set("Accepts", "application/json")
	request.Header.Add("X-CMC_PRO_API_KEY", h.Config.CoinMarket.ClientID)
	request.URL.RawQuery = q.Encode()

	response, err := client.Do(request)
	if err != nil {
		fmt.Println("Error sending request to server")
		os.Exit(1)
	}

	respBody, _ := ioutil.ReadAll(response.Body)

	data := make(map[string]map[string][]map[string]map[string]map[string]interface{})
	err = json.Unmarshal([]byte(string(respBody)), &data)
	data2 := make(map[string]map[string][]interface{})
	err = json.Unmarshal([]byte(string(respBody)), &data2)
	target := strings.Split(requestData.Target, ",")
	var resultData []message.CoinCurrentData

	for i := 0; i < len(target); i++ {
		datacount := len(data2["data"][target[i]])
		for j := 0; j < datacount; j++ {
			test, _ := data["data"][target[i]][j]["quote"][requestData.Currency]["price"].(interface{})
			test2, _ := data["data"][target[i]][j]["quote"][requestData.Currency]["last_updated"].(interface{})
			var currentData message.CoinCurrentData
			currentData.Symbol = target[i]
			currentData.Price = test.(float64)
			currentData.Time = test2.(string)
			resultData = append(resultData, currentData)
		}

	}

	result := message.CoinCurrentListResponse{
		CoinCurrentData: resultData,
	}

	if err := json.NewEncoder(w).Encode(result); err != nil {

	}

}

func (h *CoinHandler) CoinHandlerList2(w http.ResponseWriter, r *http.Request) {

	_ = r.ParseForm()
	requestData := &message.CoinCurrentListRequest{}
	decoder := schema.NewDecoder()
	err := decoder.Decode(requestData, r.Form)
	if err != nil {
		//replyError(w, requestLogger, http.StatusBadRequest, err)
		//return
	}

	client := &http.Client{}
	request, err := http.NewRequest(http.MethodGet, fmt.Sprintf("%s/v2/cryptocurrency/quotes/latest", h.Config.CoinMarket.Host), nil)
	if err != nil {
		//return err
	}
	q := url.Values{}
	//q.Add("start", "1")
	//q.Add("limit", "5000")
	q.Add("symbol", requestData.Target)
	q.Add("convert", requestData.Currency)

	request.Header.Set("Accepts", "application/json")
	request.Header.Add("X-CMC_PRO_API_KEY", h.Config.CoinMarket.ClientID)
	request.URL.RawQuery = q.Encode()

	response, err := client.Do(request)
	if err != nil {
		fmt.Println("Error sending request to server")
		os.Exit(1)
	}

	respBody, _ := ioutil.ReadAll(response.Body)

	data := message.AutoGenerated{}
	err = json.Unmarshal([]byte(string(respBody)), &data)
	fmt.Println(string(respBody))

	if err := json.NewEncoder(w).Encode(data); err != nil {

	}

}

func (h *CoinHandler) CoinHandlerHistory(w http.ResponseWriter, r *http.Request) {
	db := h.TestDB

	_ = r.ParseForm()
	requestData := &message.CoinHistoryRequest{}
	decoder := schema.NewDecoder()
	err := decoder.Decode(requestData, r.Form)
	if err != nil {
		//replyError(w, requestLogger, http.StatusBadRequest, err)
		//return
	}

	coinHistoryList, err := processor.GetCoinHistoryList(db, requestData)

	if err != nil {
		
	}

	if err := json.NewEncoder(w).Encode(coinHistoryList); err != nil {

	}
}

func (h *CoinHandler) CoinHandlerChange(w http.ResponseWriter, r *http.Request) {
	_ = r.ParseForm()

	requestData := &message.CoinChangeRequest{}
	decoder := schema.NewDecoder()
	err := decoder.Decode(requestData, r.Form)
	if err != nil {
		//replyError(w, requestLogger, http.StatusBadRequest, err)
		//return
	}

	client := &http.Client{}
	request, err := http.NewRequest(http.MethodGet, fmt.Sprintf("%s/v2/tools/price-conversion", h.Config.CoinMarket.Host), nil)
	if err != nil {
		//return err
	}
	q := url.Values{}
	q.Add("amount", requestData.Amount)
	q.Add("symbol", requestData.From)
	q.Add("convert", requestData.To)
	//time := time.Now().UTC().Format("2006-01-02T15:04:05-0700")
	//q.Add("time", time)

	request.Header.Set("Accepts", "application/json")
	request.Header.Add("X-CMC_PRO_API_KEY", h.Config.CoinMarket.ClientID)
	request.URL.RawQuery = q.Encode()

	response, err := client.Do(request)
	if err != nil {
		fmt.Println("Error sending request to server")
		os.Exit(1)
	}

	respBody, _ := ioutil.ReadAll(response.Body)

	ChangeData := message.ChangeDataResponse{}
	err = json.Unmarshal([]byte(string(respBody)), &ChangeData)

	//KEY
	data2 := make(map[string][]map[string]map[string]map[string]interface{})
	err = json.Unmarshal([]byte(string(respBody)), &data2)

	price, _ := data2["data"][0]["quote"][requestData.To]["price"].(interface{})

	result := message.CoinChangeResponse{
		Price:  ChangeData.Data[0].Quote.ATOM.Price, //ATOM
		Price2: price.(float64),                     //가변적
		Quote:  ChangeData.Data[0].Quote,            //정해진 struct

	}

	if err := json.NewEncoder(w).Encode(result); err != nil {

	}
}

/*func CoinIDReturn(symbol string, Host string) string {

	client := &http.Client{}
	request, err := http.NewRequest(http.MethodGet, fmt.Sprintf("%s/v2/cryptocurrency/info", Host), nil)

	q := url.Values{}
	q.Add("symbol", symbol)

	request.Header.Set("Accepts", "application/json")
	request.Header.Add("X-CMC_PRO_API_KEY", h.Config.CoinMarket.ClientID)
	request.URL.RawQuery = q.Encode()

	response, err := client.Do(request)
	if err != nil {
		fmt.Println("Error sending request to server")
		os.Exit(1)
	}

	respBody, _ := ioutil.ReadAll(response.Body)
	fmt.Println(string(respBody))
	data := make(map[string]map[string][]map[string]interface{})
	err = json.Unmarshal([]byte(string(respBody)), &data)
	test, _ := data["data"][symbol][0]["id"].(interface{})
	fmt.Println("*************************A")
	fmt.Println(test)
	return test.(string)
}
*/
